## 作用域是什么

作用域是一套规则，用于确定在何处以及如何查找变量。如果查找的目的是对变量进行赋值，那么就会使用 LHS 查询。如果目的是获取变量的值，就会使用 RHS 查询。赋值操作符会导致 LHS 查询。= 操作符或调用函数时传入参数的操作都会导致关联作用域的赋值操作。

**LHS 和 RHS 可以理解为：赋值操作的左侧或右侧**

javascript 引擎首先会在代码执行前对其进行编译，在这个过程中，像 `var a = 6` 这样的声明会被分解成两个独立的步骤（var与ES6中的let, const解析方式有差异）：

1. `var a` 在其作用域中声明新变量。这会在最开始的阶段，也就是代码执行前进行
2. `a =2` 会查询（LHS查询）变量 a 并对其进行赋值

LHS 和 RHS 查询都会在当前执行作用域中开始，如果有需要（也就是说他们没有找到所需的标识符），就会向上级作用域继续查找，这样每次上升一级作用域，直到抵达全局作用域，无论找到与否都将停止。

不成功的 RHS 引用会有以下两种情况：

- 非严格模式下，LHS 引用会导致自动隐私地创建一个全局变量
- 严格模式下，直接抛出ReferenceError 异常

## 提升

先来看看两段代码：

```js
a = 2;
var a;
console.log(a);
```
```js
console.log(a);
var a = 2;
```

先自己心里默默想一下答案，如果猜对了就可以跳过该小结了：

1. 输出：2
2. 输出：undefined

我们习惯将 `var a = 2;` 看作一个声明，然而实际上 Javascript 引擎并不 这么认为。它将 `var a`和 `a = 2`当作两个单独的声明，第一个编译阶段的任务，而第二个是执行阶段的任务。

再来回顾下上面的代码：

1. 编译阶段，声明了`var a`然后开始执行`a = 2`，所以输出了：2
2. 编译阶段，只声明了`var a`然后开始执行`console.log`，并没有对 a 进行赋值，所以输出了：undefined

再来看看函数：
```js
foo();
var foo;
function foo(){
    console.log(1);
}
foo = function(){
    console.log(2);
}
```
你觉得输出会是啥？

输出：1；为啥不是 2 么？尽管`var foo`出现在`function foo()...`的声明之前，但它是重复的声明（因此被忽略了）。因为函数声明会被提升到普通变量之前。

要注意避免重复声明，特别是当普通的`var`声明和函数声明混合在一起的时候，否则会引起很多危险的问题。 

